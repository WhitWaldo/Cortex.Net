<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="ActionExtensions.generated.cs" company="Michel Weststrate, Jan-Willem Spuij">
// Copyright 2019 Michel Weststrate, Jan-Willem Spuij
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// </copyright>

namespace Cortex.Net.Core
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using Cortex.Net.Api;

    /// <summary>
    /// Extension methods for <see cref="Action"/> delegates.
    /// </summary>
    public static partial class ActionExtensions
	{
<# for (int i = 0; i < 17; i++) 
{
	int j = 0;
	string typeArgs = string.Join(",", Enumerable.Repeat("T", i).Select(t => $"{t}{++j}"));
	j = 0;
	string paramArgs = string.Join(", ", Enumerable.Repeat("T", i).Select(t => $"{t}{++j} arg{j}"));
	j = 0;
	string invokeArgs = string.Join(", ", Enumerable.Repeat("T", i).Select(t => $"arg{++j}"));
	j = 0;
	string paramHeaders = string.Join(Environment.NewLine, Enumerable.Repeat("T", i).Select(t => $"        /// <param name=\"arg{++j}\">Argument nr. {j}.</param>"));
	j = 0;
	string startActionArgs = i > 0 ? "new object[] {" + string.Join(", ", Enumerable.Repeat("T", i).Select(t => $"arg{++j}")) + "}" : "Array.Empty<object>()";

	if (!string.IsNullOrEmpty(typeArgs)) typeArgs = "<" + typeArgs + ">";
	if (!string.IsNullOrEmpty(paramArgs)) paramArgs = ", " + paramArgs;
#>
	    /// <summary>
        /// Executes an Action that triggers reaction in all observables in the shared state.
        /// </summary>
        /// <param name="sharedState">The <see cref="ISharedState"/> instance to use.</param>
        /// <param name="actionName">The name of this action.</param>
        /// <param name="scope">The scope of this action.</param>
        /// <param name="action">The action itself.</param>
<#=paramHeaders#>
        internal static void ExecuteAction<#=typeArgs#>(ISharedState sharedState, string actionName, object scope, Action<#=typeArgs#> action<#=paramArgs#>)
        {
            ActionRunInfo actionRunInfo = StartAction(sharedState, actionName, scope, <#=startActionArgs#>);

            try
            {
                if (sharedState.ShouldInvoke)
                {
                    var taskScheduler = sharedState.GetTaskScheduler();
                    Task.Factory.StartNew(
                        () =>
                        {
                            action.Invoke(<#=invokeArgs#>);
                        },
                        CancellationToken.None,
                        TaskCreationOptions.DenyChildAttach,
                        taskScheduler).ContinueWith(
                            t =>
                            {
                                if (t.Exception != null)
                                {
                                    throw t.Exception;
                                }
                            }, taskScheduler);
                }
                else
                {
                    action.Invoke(<#=invokeArgs#>);
                }
            }
            catch (Exception exception)
            {
                actionRunInfo.Exception = exception;
                throw;
            }
            finally
            {
                EndAction(actionRunInfo);
            }
        }

<# } #>
	}
}